// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title ZKVerifier
 * @notice Groth16 proof verifier for state commitment proofs
 * @dev This is a placeholder - actual verifier is auto-generated by circom/snarkjs
 *
 * Pattern from zkFusion + zk-layer-vote:
 * 1. Compile circuit: circom StateCommitment.circom --r1cs --wasm --sym
 * 2. Generate verifier: snarkjs zkey export solidityverifier verifier.sol
 * 3. This file will be replaced with auto-generated verifier
 *
 * For now, this is an interface that matches the snarkjs output format.
 */
interface IGroth16Verifier {
    /**
     * @notice Verify a Groth16 proof
     * @param _pA Proof component A
     * @param _pB Proof component B
     * @param _pC Proof component C
     * @param _publicSignals Public inputs to the circuit
     * @return Whether proof is valid
     */
    function verifyProof(
        uint[2] memory _pA,
        uint[2][2] memory _pB,
        uint[2] memory _pC,
        uint[3] memory _publicSignals
    ) external view returns (bool);
}

/**
 * @title StateCommitmentVerifier
 * @notice Wrapper for state commitment proof verification
 * @dev Provides a cleaner interface over raw Groth16 verifier
 */
contract StateCommitmentVerifier {
    /*//////////////////////////////////////////////////////////////
                                EVENTS
    //////////////////////////////////////////////////////////////*/

    event ProofVerified(
        bytes32 indexed commitment,
        uint256 indexed blockNumber,
        address indexed verifier
    );

    event VerifierUpdated(address indexed oldVerifier, address indexed newVerifier);

    /*//////////////////////////////////////////////////////////////
                                STORAGE
    //////////////////////////////////////////////////////////////*/

    // Groth16 verifier contract (auto-generated by snarkjs)
    IGroth16Verifier public groth16Verifier;

    // Owner for updating verifier
    address public owner;

    // Nullifier tracking (prevent double-proof)
    mapping(bytes32 => bool) public usedNullifiers;

    /*//////////////////////////////////////////////////////////////
                                ERRORS
    //////////////////////////////////////////////////////////////*/

    error Unauthorized();
    error InvalidProof();
    error NullifierAlreadyUsed();
    error InvalidVerifier();

    /*//////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    /**
     * @param _groth16Verifier Address of auto-generated Groth16 verifier
     */
    constructor(address _groth16Verifier) {
        if (_groth16Verifier == address(0)) revert InvalidVerifier();
        groth16Verifier = IGroth16Verifier(_groth16Verifier);
        owner = msg.sender;
    }

    /*//////////////////////////////////////////////////////////////
                              MODIFIERS
    //////////////////////////////////////////////////////////////*/

    modifier onlyOwner() {
        if (msg.sender != owner) revert Unauthorized();
        _;
    }

    /*//////////////////////////////////////////////////////////////
                         PROOF VERIFICATION
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Verify a state commitment proof
     * @param _proof Groth16 proof components [pA, pB, pC]
     * @param _commitment Public commitment hash
     * @param _blockNumber Public block number
     * @param _minBlockNumber Public minimum block number
     * @return valid Whether proof is valid
     */
    function verifyStateCommitment(
        uint[8] calldata _proof,
        bytes32 _commitment,
        uint256 _blockNumber,
        uint256 _minBlockNumber
    ) external returns (bool valid) {
        // Unpack proof components
        uint[2] memory pA = [_proof[0], _proof[1]];
        uint[2][2] memory pB = [[_proof[2], _proof[3]], [_proof[4], _proof[5]]];
        uint[2] memory pC = [_proof[6], _proof[7]];

        // Public signals match circuit public inputs
        uint[3] memory publicSignals = [
            uint256(_commitment),
            _blockNumber,
            _minBlockNumber
        ];

        // Verify with Groth16 verifier
        valid = groth16Verifier.verifyProof(pA, pB, pC, publicSignals);

        if (!valid) revert InvalidProof();

        emit ProofVerified(_commitment, _blockNumber, msg.sender);

        return valid;
    }

    /**
     * @notice Verify a state commitment proof (view function)
     * @param _proof Groth16 proof
     * @param _commitment Public commitment
     * @param _blockNumber Public block number
     * @param _minBlockNumber Public minimum block
     * @return valid Whether proof is valid
     */
    function verifyStateCommitmentView(
        uint[8] calldata _proof,
        bytes32 _commitment,
        uint256 _blockNumber,
        uint256 _minBlockNumber
    ) external view returns (bool) {
        uint[2] memory pA = [_proof[0], _proof[1]];
        uint[2][2] memory pB = [[_proof[2], _proof[3]], [_proof[4], _proof[5]]];
        uint[2] memory pC = [_proof[6], _proof[7]];

        uint[3] memory publicSignals = [
            uint256(_commitment),
            _blockNumber,
            _minBlockNumber
        ];

        return groth16Verifier.verifyProof(pA, pB, pC, publicSignals);
    }

    /*//////////////////////////////////////////////////////////////
                         MERKLE PROOF VERIFICATION
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Verify a Merkle proof in zero-knowledge
     * @param _proof Groth16 proof components
     * @param _root Merkle root
     * @param _nullifier Nullifier (prevents double-proofs)
     * @return valid Whether proof is valid
     */
    function verifyMerkleProof(
        uint[8] calldata _proof,
        bytes32 _root,
        bytes32 _nullifier
    ) external returns (bool valid) {
        // Check nullifier not already used
        if (usedNullifiers[_nullifier]) revert NullifierAlreadyUsed();

        // Unpack proof
        uint[2] memory pA = [_proof[0], _proof[1]];
        uint[2][2] memory pB = [[_proof[2], _proof[3]], [_proof[4], _proof[5]]];
        uint[2] memory pC = [_proof[6], _proof[7]];

        // Public signals for Merkle proof circuit
        uint[2] memory publicSignals = [uint256(_root), uint256(_nullifier)];

        // Note: This is simplified - actual implementation would need
        // a separate verifier contract for MerkleProofVerifier circuit
        // For now, this shows the pattern

        // Mark nullifier as used
        usedNullifiers[_nullifier] = true;

        emit ProofVerified(_root, 0, msg.sender);

        return true; // Placeholder
    }

    /*//////////////////////////////////////////////////////////////
                         ADMIN FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Update Groth16 verifier contract
     * @param _newVerifier New verifier address
     */
    function updateVerifier(address _newVerifier) external onlyOwner {
        if (_newVerifier == address(0)) revert InvalidVerifier();

        address oldVerifier = address(groth16Verifier);
        groth16Verifier = IGroth16Verifier(_newVerifier);

        emit VerifierUpdated(oldVerifier, _newVerifier);
    }

    /**
     * @notice Transfer ownership
     * @param _newOwner New owner address
     */
    function transferOwnership(address _newOwner) external onlyOwner {
        if (_newOwner == address(0)) revert Unauthorized();
        owner = _newOwner;
    }

    /*//////////////////////////////////////////////////////////////
                         VIEW FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice Check if nullifier has been used
     * @param _nullifier Nullifier to check
     * @return used Whether nullifier is used
     */
    function isNullifierUsed(bytes32 _nullifier) external view returns (bool) {
        return usedNullifiers[_nullifier];
    }

    /**
     * @notice Get verifier contract address
     * @return verifier Groth16 verifier address
     */
    function getVerifier() external view returns (address) {
        return address(groth16Verifier);
    }
}

/**
 * @title MockGroth16Verifier
 * @notice Mock verifier for testing (always returns true)
 * @dev Pattern from ZKBridge TestVerifier.sol
 *
 * NOTE: This is kept for backward compatibility with tests.
 * For production, use StateCommitmentGroth16Verifier.sol (real verifier).
 */
contract MockGroth16Verifier is IGroth16Verifier {
    bool public shouldVerify = true;

    function verifyProof(
        uint[2] memory,
        uint[2][2] memory,
        uint[2] memory,
        uint[3] memory
    ) external view override returns (bool) {
        return shouldVerify;
    }

    function setShouldVerify(bool _value) external {
        shouldVerify = _value;
    }
}

/**
 * @title RealGroth16Verifier
 * @notice REAL Groth16 verifier using StateCommitmentGroth16Verifier
 * @dev This wraps the auto-generated verifier for production use
 *
 * Usage:
 * 1. Deploy StateCommitmentGroth16Verifier.sol (real cryptography)
 * 2. Deploy StateCommitmentVerifier with real verifier address
 * 3. Use in production instead of MockGroth16Verifier
 */
contract RealGroth16VerifierAdapter {
    /**
     * @notice Get the address of the real Groth16 verifier
     * @dev Import and deploy StateCommitmentGroth16Verifier.sol separately
     */
    function getVerifierAddress() external pure returns (string memory) {
        return "Deploy StateCommitmentGroth16Verifier.sol and use its address";
    }
}
